---
layout: post
title: Sort algorithm
description: "Conclude some sort algorithm."
modified: 2014-05-28
tags: [algorithm]
image:
  feature: abstract-3.jpg
  credit: dargadgetz
comments: true
share: true

---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Sort</h2>
<div class="outline-text-2" id="text-1">
<p>
Input: sequence \(<a_1, a_2, ... , a_n>\) of numbers.
Output: permutation \(<a_1', a_2',... ,a_n'>\), such that
\(a_1'<=a_2'...<=a_n'\).
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Selection sort(选择排序：最直观)</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li><b>Introduction</b>
In computer science, selection sort is a sorting algorithm,
specifically an in-place comparison sort. It has O(n2) time
complexity, making it inefficient on large lists, and generally
performs worse than the similar insertion sort. Selection sort is
noted for its simplicity, and it has performance advantages over more
complicated algorithms in certain situations, particularly where
auxiliary memory is limited.

<p>
选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首
先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再
从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以
此类推，直到所有元素均排序完毕。
</p>
</li>

<li><b>Example</b>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">64</td>
<td class="right">25</td>
<td class="right">12</td>
<td class="right">22</td>
<td class="right">11</td>
</tr>

<tr>
<td class="right">11</td>
<td class="right">64</td>
<td class="right">25</td>
<td class="right">12</td>
<td class="right">22</td>
</tr>

<tr>
<td class="right">11</td>
<td class="right">12</td>
<td class="right">64</td>
<td class="right">25</td>
<td class="right">22</td>
</tr>

<tr>
<td class="right">11</td>
<td class="right">12</td>
<td class="right">22</td>
<td class="right">64</td>
<td class="right">25</td>
</tr>

<tr>
<td class="right">11</td>
<td class="right">12</td>
<td class="right">22</td>
<td class="right">25</td>
<td class="right">64</td>
</tr>
</tbody>
</table>
</li>

<li><b>visualization</b>

<p>
两个直观图：
</p>

<p>
<img src="../Pic/Selection-sort-animation-1.gif" alt="Selection-sort-animation-1.gif" />
<img src="../Pic/Selection-sort-animation-2.gif" alt="Selection-sort-animation-2.gif" />
</p>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">def</span> <span style="color: #A6E22E;">selection_sort</span>(sequence):
    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(0, <span style="color: #F92672;">len</span>(sequence)):
        <span style="color: #FD971F;">min_of_seq</span> = i
        <span style="color: #F92672;">for</span> j <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(i, <span style="color: #F92672;">len</span>(sequence)):
            <span style="color: #F92672;">if</span> sequence[j] &lt; sequence[i]:
                <span style="color: #FD971F;">min_of_seq</span> = j
        <span style="color: #F92672;">if</span> <span style="color: #F92672;">min</span> != i:
            <span style="color: #FD971F;">tmp</span> = sequence[i]
            <span style="color: #FD971F;">sequence</span>[i] = sequence[min_of_seq]
            <span style="color: #FD971F;">sequence</span>[min_of_seq] = tmp
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Insertion sort(插入排序：依赖输入)</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li><b>Introduction</b>
Insertion sort is a simple sorting algorithm that builds the final
sorted array (or list) one item at a time. It is much less efficient
on large lists than more advanced algorithms such as quicksort,
heapsort, or merge sort. However, insertion sort provides several
advantages:

<ul class="org-ul">
<li>Simple implementation
</li>
<li>Efficient for (quite) small data sets
</li>
<li>Adaptive (i.e., efficient) for data sets that are already substantially sorted: the time complexity is O(n + d), where d is the number of inversions
</li>
<li>More efficient in practice than most other simple quadratic (i.e., O(n2)) algorithms such as selection sort or bubble sort; the best case (nearly sorted input) is O(n)
</li>
<li>Stable; i.e., does not change the relative order of elements with equal keys
</li>
<li>In-place; i.e., only requires a constant amount O(1) of additional memory space
</li>
<li>Online; i.e., can sort a list as it receives it
</li>
</ul>
</li>

<li><b>Example</b>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">8</td>
<td class="right">2</td>
<td class="right">4</td>
<td class="right">9</td>
<td class="right">3</td>
<td class="right">6</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">8</td>
<td class="right">4</td>
<td class="right">9</td>
<td class="right">3</td>
<td class="right">6</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">4</td>
<td class="right">8</td>
<td class="right">9</td>
<td class="right">3</td>
<td class="right">6</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">4</td>
<td class="right">8</td>
<td class="right">9</td>
<td class="right">3</td>
<td class="right">6</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">3</td>
<td class="right">4</td>
<td class="right">8</td>
<td class="right">9</td>
<td class="right">6</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">3</td>
<td class="right">4</td>
<td class="right">6</td>
<td class="right">8</td>
<td class="right">9</td>
</tr>
</tbody>
</table>
</li>

<li><b>visualization</b>

<p>
两个直观图：
</p>

<p>
<img src="../Pic/Insertion-sort-animation-1.gif" alt="Insertion-sort-animation-1.gif" />
<img src="../Pic/Insertion-sort-animation-2.gif" alt="Insertion-sort-animation-2.gif" />
</p>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">def</span> <span style="color: #A6E22E;">insertion_sort</span>(sequence):
    <span style="color: #F92672;">if</span> <span style="color: #F92672;">len</span>(sequence) &lt;= 1:
        <span style="color: #F92672;">return</span> sequence
    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(1,<span style="color: #F92672;">len</span>(sequence)):
        <span style="color: #FD971F;">key</span> = sequence[i]
        <span style="color: #FD971F;">j</span> = i-1
        <span style="color: #F92672;">while</span> (j &gt;= 0) <span style="color: #F92672;">and</span> (sequence[j]&gt;key):
            <span style="color: #FD971F;">sequence</span>[j+1] = sequence[j]
            <span style="color: #FD971F;">j</span> = j-1
        <span style="color: #FD971F;">sequence</span>[j+1] = key
</pre>
</div>

<p>
我又用Scheme做了实现：
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672;">define</span> <span style="color: #A6E22E;">Insertion-sort</span>
  (<span style="color: #F92672;">lambda</span> (sequence)
    (<span style="color: #F92672;">if</span> (<span style="color: #F92672;">or</span> (null? sequence) (&lt;= (length sequence) 1))
            sequence
            (insert (car sequence) (Insertion-sort (cdr sequence))))))

(<span style="color: #F92672;">define</span> <span style="color: #A6E22E;">insert</span>
  (<span style="color: #F92672;">lambda</span> (x sequence)
    (<span style="color: #F92672;">cond</span>
     ((null? sequence) (cons x sequence))
     ((&lt; x (car sequence)) (cons x sequence))
     (<span style="color: #F92672;">else</span> (cons (car sequence) (insert x (cdr sequence)))))))
</pre>
</div>

<ul class="org-ul">
<li><b>Running time:</b>
</li>
<li>Depends on input(e.g. already sorted).
</li>
<li>Depends on input size.
</li>
<li>Want upper bonds.
</li>

<li><b>Kinds of analysis</b>
<ul class="org-ul">
<li>Worst-case:(usually)
</li>
</ul>
<p>
T(n) = max time on any input of size n.
</p>

<ul class="org-ul">
<li>Average-case:(sometimes)
</li>
</ul>
<p>
T(n) = expected time over all input of size n.
</p>

<ul class="org-ul">
<li>Best-case:(bogus)
</li>

<li>Big-Idea:
</li>
</ul>
<p>
Growth of running time.
</p>

<p>
\(\Theta\)-notation: Drop low-order terms and Ignore leading
constants.
</p>

<p>
Ex: \(3*n^3+90*n^2-5n-63 = \Theta(n^3)\)
</p>
</li>

<li><b>Insertion sort analysis</b>
  Worse-case(input reverse sorted):
<div class="org-src-container">

<pre class="src src-latex"><span style="color: #F92672;">\begin</span>{<span style="color: #A6E22E;">equation</span>}
T(n) = <span style="color: #F92672;">\sum</span>_{j=2}^n <span style="color: #F92672;">\Theta</span>(j) = <span style="color: #F92672;">\Theta</span>(n^2)
<span style="color: #F92672;">\end</span>{<span style="color: #A6E22E;">equation</span>}
</pre>
</div>

<p>
Not very fast.
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Merge sort(归并排序：分治思想)</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><b>Introduction</b>

<p>
In computer science, merge sort (also commonly spelled mergesort) is
an O(n log n) comparison-based sorting algorithm. Most implementations
produce a stable sort, which means that the implementation preserves
the input order of equal elements in the sorted output. Mergesort is a
divide and conquer algorithm that was invented by John von Neumann
in 1945. A detailed description and analysis of bottom-up mergesort
appeared in a report by Goldstine and Neumann as early as 1948.
</p>

<p>
归并操作的过程如下：
</p>

<ul class="org-ul">
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置
</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
</li>
<li>重复步骤3直到某一指针达到序列尾
</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾
</li>
</ul>
</li>

<li><b>Example</b>

<p>
NULL.
</p>
</li>

<li><b>visualization</b>

<p>
两个直观图：
</p>

<p>
<img src="../Pic/Merge-sort-animation-1.gif" alt="Merge-sort-animation-1.gif" />
<img src="../Pic/Merge-sort-animation-2.gif" alt="Merge-sort-animation-2.gif" />
</p>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">class</span> <span style="color: #66D9EF; font-style: italic;">MergeSort</span>(<span style="color: #F92672;">object</span>):
    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">__init__</span>(<span style="color: #F92672;">self</span>, seq):
        <span style="color: #E6DB74;">"docstring"</span>
        <span style="color: #F92672;">self</span>.sequence = seq

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">merge</span>(<span style="color: #F92672;">self</span>, left, right):
        <span style="color: #FD971F;">serted_seq</span> = []
        <span style="color: #F92672;">while</span> left <span style="color: #F92672;">and</span> right:
            <span style="color: #F92672;">if</span> left[0] &lt;= right[0]:
                serted_seq.append(left.pop(0))
            <span style="color: #F92672;">else</span>:
                serted_seq.append(right.pop(0))
        <span style="color: #F92672;">return</span> serted_seq+left+right

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">merge_sort_recursion</span>(<span style="color: #F92672;">self</span>, sequence):
        <span style="color: #FD971F;">mid</span> = <span style="color: #F92672;">int</span>(<span style="color: #F92672;">len</span>(sequence)/2)
        <span style="color: #F92672;">if</span> <span style="color: #F92672;">len</span>(sequence) &lt;= 1:
            <span style="color: #F92672;">return</span> sequence
        <span style="color: #F92672;">return</span> <span style="color: #F92672;">self</span>.merge(<span style="color: #F92672;">self</span>.merge_sort_recursion(sequence[:mid]), <span style="color: #F92672;">self</span>.merge_sort_recursion(sequence[mid:]))

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">merge_sort_iteration</span>(<span style="color: #F92672;">self</span>):
        <span style="color: #FD971F;">Q</span> = []
        <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="color: #F92672;">self</span>.sequence:
            Q.append([i])
        <span style="color: #F92672;">while</span> <span style="color: #F92672;">len</span>(Q) &gt; 1:
            Q.append(<span style="color: #F92672;">self</span>.merge(Q.pop(0), Q.pop(0)))
        <span style="color: #F92672;">return</span> Q.pop()
</pre>
</div>

<p>
这里的代码摘自Wiki，给出了两种调用方式，一种称之为迭代，一种为递归。但
是两者到底什么区别，有待思考。
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Buddle sort(冒泡排序：最慢)</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li><b>Introduction</b>

<p>
Bubble sort, sometimes incorrectly referred to as sinking sort, is a
simple sorting algorithm that works by repeatedly stepping through
the list to be sorted, comparing each pair of adjacent items and
swapping them if they are in the wrong order. The pass through the
list is repeated until no swaps are needed, which indicates that the
list is sorted. The algorithm gets its name from the way smaller
elements "bubble" to the top of the list. Because it only uses
comparisons to operate on elements, it is a comparison
sort. Although the algorithm is simple, most of the other sorting
algorithms are more efficient for large lists.
</p>

<p>
冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排
序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序
错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，
也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由
交换慢慢“浮”到数列的顶端。
</p>

<p>
冒泡排序算法的运作如下：
</p>

<ul class="org-ul">
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。
</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。
</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
</li>
</ul>
</li>

<li><b>Example</b>

<p>
NULL
</p>
</li>

<li><b>visualization</b>

<p>
一个直观图：
</p>


<div class="figure">
<p><img src="../Pic/Buddle-sort-animation-1.gif" alt="Buddle-sort-animation-1.gif" />
</p>
</div>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">def</span> <span style="color: #A6E22E;">buddle_sort</span>(sequence):
    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(0, <span style="color: #F92672;">len</span>(sequence)):
        <span style="color: #F92672;">for</span> j <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(i,<span style="color: #F92672;">len</span>(sequence)):
            <span style="color: #F92672;">if</span> sequence[i] &gt; sequence[j]:
                <span style="color: #FD971F;">tmp</span> = sequence[i]
                <span style="color: #FD971F;">sequence</span>[i] = sequence[j]
                <span style="color: #FD971F;">sequence</span>[j] = tmp
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Quick sort(快速排序：用的最多)</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li><b>Introduction</b>

<p>
Quicksort, or partition-exchange sort, is a sorting algorithm
developed by Tony Hoare that, on average, makes O(n log n)
comparisons to sort n items. In the worst case, it makes O(n2)
comparisons, though this behavior is rare. Quicksort is often faster
in practice than other O(n log n) algorithms. Additionally,
quicksort's sequential and localized memory references work well
with a cache. Quicksort is a comparison sort and, in efficient
implementations, is not a stable sort. Quicksort can be implemented
with an in-place partitioning algorithm, so the entire sort can be
done with only O(log n) additional space used by the stack during
the recursion.
</p>

<p>
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项
目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并
不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的
内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
</p>
</li>
</ul>


<p>
快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
</p>

<p>
步骤为：
</p>

<ul class="org-ul">
<li>从数列中挑出一个元素，称为 "基准"（pivot），
</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数
列排序。
</li>

<li><b>Example</b>

<p>
NULL
</p>
</li>

<li><b>visualization</b>

<p>
两个直观图：
</p>


<div class="figure">
<p><img src="../Pic/Quick-sort-1.jpg" alt="Quick-sort-1.jpg" />
</p>
</div>


<div class="figure">
<p><img src="../Pic/Quick-sort-animation-2.gif" alt="Quick-sort-animation-2.gif" />
</p>
</div>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">class</span> <span style="color: #66D9EF; font-style: italic;">QuickSort</span>(<span style="color: #F92672;">object</span>):
    <span style="color: #E6DB74;">'Define QuickSort class'</span>
    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">__init__</span>(<span style="color: #F92672;">self</span>, seq):
        <span style="color: #E6DB74;">"docstring"</span>
        <span style="color: #F92672;">self</span>.sequence = seq

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">swap</span>(<span style="color: #F92672;">self</span>, i, j):
        <span style="color: #E6DB74;">"swap two values of sequence"</span>
        <span style="color: #FD971F;">tmp</span> = <span style="color: #F92672;">self</span>.sequence[i]
        <span style="color: #F92672;">self</span>.sequence[i] = <span style="color: #F92672;">self</span>.sequence[j]
        <span style="color: #F92672;">self</span>.sequence[j] = tmp

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">rand</span>(<span style="color: #F92672;">self</span>, p, q):
        <span style="color: #E6DB74;">"return a integer number belong [p,q)"</span>

        <span style="color: #E6DB74;">'''random.randint: similar to 'random_integers',</span>
<span style="color: #E6DB74;">        random.randint only for the half-open interval ['low', 'high'),</span>
<span style="color: #E6DB74;">        random.random_integers for close interval ['low', 'high']'''</span>
        <span style="color: #F92672;">return</span> np.random.randint(p,q)

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">rand_partition</span>(<span style="color: #F92672;">self</span>, p, q):
        <span style="color: #E6DB74;">"random partition a sequence"</span>
        <span style="color: #F92672;">self</span>.swap(<span style="color: #F92672;">self</span>.rand(p,q), p)
        <span style="color: #FD971F;">key</span> = <span style="color: #F92672;">self</span>.sequence[p]
        <span style="color: #FD971F;">i</span> = p

        <span style="color: #F92672;">for</span> j <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(p+1, q+1):
            <span style="color: #F92672;">if</span> <span style="color: #F92672;">self</span>.sequence[j] &lt;= key:
                <span style="color: #FD971F;">i</span> = i+1
                <span style="color: #F92672;">self</span>.swap(i, j)
        <span style="color: #F92672;">self</span>.swap(i, p)
        <span style="color: #F92672;">return</span> i

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">rand_quick_sort</span>(<span style="color: #F92672;">self</span>, p, q):
        <span style="color: #F92672;">if</span> p &lt; q:
            <span style="color: #FD971F;">i</span> = <span style="color: #F92672;">self</span>.rand_partition(p, q)
            <span style="color: #F92672;">self</span>.rand_quick_sort(p, i-1)
            <span style="color: #F92672;">self</span>.rand_quick_sort(i+1, q)
</pre>
</div>

<p>
我又用Lisp做了实现:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #F92672;">define</span> (<span style="color: #A6E22E;">q-sort</span> lst)
  (<span style="color: #F92672;">if</span> (null? lst)
      lst
      (append (q-sort (filter (<span style="color: #F92672;">lambda</span> (x) (&lt;= x (car lst))) (cdr lst)))
              (list (car lst))
              (q-sort (filter (<span style="color: #F92672;">lambda</span> (x) (&gt; x (car lst))) (cdr lst))))))
</pre>
</div>

<p>
观察到基于函数编程的思想，代码可以简化如此之多，那么Python同样支持函数
编程，拿Python加函数式实现又会怎样呢？
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">def</span> <span style="color: #A6E22E;">QuickSortFun</span>(lst):
    <span style="color: #F92672;">if</span> lst:
        <span style="color: #F92672;">print</span> QuickSortFun(<span style="color: #F92672;">filter</span>(<span style="color: #F92672;">lambda</span> x:x&lt;=lst[0], lst[1:])), lst[0],
        QuickSortFun(<span style="color: #F92672;">filter</span>(<span style="color: #F92672;">lambda</span> x:x&gt;lst[0], lst[1:]))
</pre>
</div>

<p>
嗯，o(╯□╰)o，准确的说只有三行。。。
</p>

<ul class="org-ul">
<li><b>算法分析：</b>
<ul class="org-ul">
<li>最坏情况
</li>
</ul>
<p>
当输入数组已经完全排好序时（不管是正序还是倒序），快速排序的运行时间
最差，为$&Theta;(n<sup>2</sup>)$。*而在这样的情况下，插入排序的运行时间为
$&Theta;(n)$。
</p>

<ul class="org-ul">
<li>最佳情况划分
</li>
</ul>
<p>
对半划分是快速排序的最佳情况，运行时间为$&Theta;(n lg n)$。
</p>

<ul class="org-ul">
<li>其他情况
</li>
</ul>
<p>
<b>快速排序的平均运行时间与其最佳情况运行时间很接近，而不是非常接近与
其最坏情况运行时间。</b>
</p>

<p>
可证明，不管是对半划分还是9：1划分，或者99：1划分，甚至一次好的划分，
一次失败划分（一个大小为n，另一个为大小为0）交替进行，最后算法运行时
间都是$&Theta;(n lg n)$。
</p>
</li>

<li><b>算法改进：随机快速排序</b>

<p>
基于上面的分析，我们只要保证输入数组不是完全排好序的数列即可使快速排序
达到理想的运行时间，这里的策略是随机化选择主元。
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Shell sort(希尔排序：选择排序升级版)</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li><b>Introduction</b>
Shellsort, also known as Shell sort or Shell's method, is an in-place
comparison sort. It can either be seen as a generalization of sorting
by exchange (bubble sort) or sorting by insertion (insertion sort).
The method starts by sorting elements far apart from each other and
progressively reducing the gap between them. Starting with far apart
elements can move some out-of-place elements into position faster than
a simple nearest neighbor exchange. Donald Shell published the first
version of this sort in 1959. The running time of Shellsort is
heavily dependent on the gap sequence it uses. For many practical
variants, determining their time complexity remains an open problem.

<p>
希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。
希尔排序是基于插入排序的以下两点性质而提出改进方法的：
</p>

<ul class="org-ul">
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率
</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位
</li>
</ul>
</li>

<li><b>Example</b>


<div class="figure">
<p><img src="../Pic/Shell-sort-animation-2.png" alt="Shell-sort-animation-2.png" />
</p>
</div>
</li>

<li><b>visualization</b>


<div class="figure">
<p><img src="../Pic/Shell-sort-animation-1.gif" alt="Shell-sort-animation-1.gif" />
</p>
</div>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">def</span> <span style="color: #A6E22E;">shell_sort</span>(sequence):
    <span style="color: #FD971F;">step</span> = <span style="color: #F92672;">len</span>(sequence)/2
    <span style="color: #F92672;">while</span> step &gt; 0:
        <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(step, <span style="color: #F92672;">len</span>(sequence)):
            <span style="color: #FD971F;">key</span> = sequence[i]
            <span style="color: #FD971F;">j</span> = i
            <span style="color: #F92672;">while</span> j &gt;= step <span style="color: #F92672;">and</span> sequence[j-step] &gt; key:
                <span style="color: #FD971F;">sequence</span>[j] = sequence[j-step]
                <span style="color: #FD971F;">j</span> = j - step
            <span style="color: #FD971F;">sequence</span>[j] = key
        <span style="color: #FD971F;">step</span> = step/2
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Heap sort(堆排序：插入排序升级版)</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li><b>Introduction</b>

<p>
Heapsort is a comparison-based sorting algorithm. Heapsort is part of
the selection sort family; it improves on the basic selection sort by
using a logarithmic-time priority queue rather than a linear-time
search. Although somewhat slower in practice on most machines than a
well-implemented quicksort, it has the advantage of a more favorable
worst-case O(n log n) runtime. Heapsort is an in-place algorithm, but
it is not a stable sort. It was invented by J. W. J. Williams in 1964.
</p>

<p>
算法思想：堆是一种数据结构，最好的理解堆的方式就是把堆看成一棵完全二叉树，这个完全二叉树满足任何一个非叶节点的值，都不大于（或不小于）其左右孩子节点的值。若父亲大孩子小，则这样的堆叫做大顶堆；若父亲小孩子大，这样的堆叫做小顶堆。根据堆的定义，其根节点的值是最大（或最小），因此将一个无序序列调整为一个堆，就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1个，对新的无序序列重复这样的操作，就实现了序列排序。堆排序中最关键的操作是将序列调整为堆，整个排序的过程就是通过不断调整使得不符合堆定义的完全二叉树变为符合堆定义的完全二叉树的过程。
</p>

<p>
堆排序执行过程（大顶堆）：
</p>
</li>
</ul>
<p>
（1）从无序序列所确定的完全二叉树的第一个非叶子节点开始，从右至左，从下至上，对每个节点进行调整，最终将得到一个大顶堆。将当前节点（a）的值与其孩子节点进行比较，如果存在大于a值的孩子节点，则从中选出最大的一个与a交换。当a来到下一层的时候重复上述过程，直到a的孩子节点值都小于a的值为止。
（2）将当前无序序列中第一个元素，在树中是根节点（a）与无序序列中最后一个元素（b）交换。a进入有序序列，到达最终位置，无序序列中元素减少1个，有序序列中元素增加1个，此时只有节点b可能不满足堆的定义，对其进行调整。
</p>

<p>
（3）重复过程2，直到无序序列中的元素剩下1个时排序结束。
</p>

<ul class="org-ul">
<li><b>Example</b>

<p>
Let { 6, 5, 3, 1, 8, 7, 2, 4 } be the list that we want to sort from
the smallest to the largest. (NOTE, for 'Building the Heap' step:
Larger nodes don't stay below smaller node parents. They are swapped
with parents, and then recursively checked if another swap is needed,
to keep larger numbers above smaller numbers on the heap binary tree.)
</p>
</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Heap</td>
<td class="right">newly added element</td>
<td class="left">swap elements</td>
</tr>

<tr>
<td class="left">nil</td>
<td class="right">6</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">6</td>
<td class="right">5</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">6, 5</td>
<td class="right">3</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">6, 5, 3</td>
<td class="right">1</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">6, 5, 3, 1</td>
<td class="right">8</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">6, 5, 3, 1, 8</td>
<td class="right">&#xa0;</td>
<td class="left">5, 8</td>
</tr>

<tr>
<td class="left">6, 8, 3, 1, 5</td>
<td class="right">&#xa0;</td>
<td class="left">6, 8</td>
</tr>

<tr>
<td class="left">8, 6, 3, 1, 5  7</td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">8, 6, 3, 1, 5, 7</td>
<td class="right">&#xa0;</td>
<td class="left">3, 7</td>
</tr>

<tr>
<td class="left">8, 6, 7, 1, 5, 3</td>
<td class="right">2</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">8, 6, 7, 1, 5, 3, 2</td>
<td class="right">4</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">8, 6, 7, 1, 5, 3, 2, 4</td>
<td class="right">&#xa0;</td>
<td class="left">1, 4</td>
</tr>

<tr>
<td class="left">8, 6, 7, 4, 5, 3, 2, 1</td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>


<div class="figure">
<p><img src="../Pic/Heap-sort-animation-2.gif" alt="Heap-sort-animation-2.gif" />
</p>
</div>

<ul class="org-ul">
<li><b>visualization</b>

<p>
 一个直观图：
<img src="../Pic/Heap-sort-animation-1.gif" alt="Heap-sort-animation-1.gif" />
</p>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">def</span> <span style="color: #A6E22E;">heap_sort</span>(lst):
    <span style="color: #F92672;">for</span> start <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>((<span style="color: #F92672;">len</span>(lst)-2)/2,-1,-1):
        sift_down(lst,start,<span style="color: #F92672;">len</span>(lst)-1)

    <span style="color: #F92672;">for</span> end <span style="color: #F92672;">in</span> <span style="color: #F92672;">range</span>(<span style="color: #F92672;">len</span>(lst)-1,0,-1):
        lst[0],<span style="color: #FD971F;">lst</span>[end] = lst[end],lst[0]
        sift_down(lst,0,end-1)
    <span style="color: #F92672;">return</span> lst

<span style="color: #F92672;">def</span> <span style="color: #A6E22E;">sift_down</span>(lst,start,end):
    <span style="color: #FD971F;">root</span> = start
    <span style="color: #F92672;">while</span> <span style="color: #AE81FF;">True</span>:
        <span style="color: #FD971F;">child</span> = 2*root + 1
        <span style="color: #F92672;">if</span> child &gt; end:
            <span style="color: #F92672;">break</span>
        <span style="color: #F92672;">if</span> child+1 &lt;= end <span style="color: #F92672;">and</span> lst[child] &lt; lst[child+1]:
            <span style="color: #FD971F;">child</span> += 1
        <span style="color: #F92672;">if</span> lst[root] &lt; lst[child]:
            lst[root],<span style="color: #FD971F;">lst</span>[child] = lst[child],lst[root]
            <span style="color: #FD971F;">root</span> = child
        <span style="color: #F92672;">else</span>:
            <span style="color: #F92672;">break</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Bucket sort(桶排序：号称最快)</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li><b>Introduction</b>
Bucket sort, or bin sort, is a sorting algorithm that works by
partitioning an array into a number of buckets. Each bucket is then
sorted individually, either using a different sorting algorithm, or by
recursively applying the bucket sorting algorithm. It is a
distribution sort, and is a cousin of radix sort in the most to least
significant digit flavour. Bucket sort is a generalization of
pigeonhole sort. Bucket sort can be implemented with comparisons and
therefore can also be considered a comparison sort algorithm. The
computational complexity estimates involve the number of buckets.

<p>
桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数
组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法
或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结
果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ
（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。
</p>

<p>
桶排序以下列程序进行：
</p>

<ul class="org-ul">
<li>设置一个定量的数组当作空桶子。
</li>
<li>寻访串行，并且把项目一个一个放到对应的桶子去。
</li>
<li>对每个不是空的桶子进行排序。
</li>
<li>从不是空的桶子里把项目再放回原来的串行中。
</li>
</ul>
</li>

<li><b>Example</b>

<p>
<img src="../Pic/Bucket-sort-1.png" alt="Bucket-sort-1.png" />
<img src="../Pic/Bucket-sort-2.png" alt="Bucket-sort-2.png" />
</p>
</li>
</ul>


<ul class="org-ul">
<li><b>visualization</b>

<p>
NULL
</p>
</li>

<li><b>Code</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F92672;">class</span> <span style="color: #66D9EF; font-style: italic;">BucketSort</span>(<span style="color: #F92672;">object</span>):
    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">__init__</span>(<span style="color: #F92672;">self</span>, seq):
        <span style="color: #E6DB74;">"Bucket sort init function"</span>
        <span style="color: #F92672;">self</span>.sequence = seq

    <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">bucket_sort</span>(<span style="color: #F92672;">self</span>):
        <span style="color: #75715E;"># </span><span style="color: #75715E;">How to build a list of length n, in which each element is [], [[],[],[],[]]</span>
        <span style="color: #FD971F;">buckets</span> = [[] <span style="color: #F92672;">for</span> _ <span style="color: #F92672;">in</span> <span style="color: #F92672;">xrange</span>(<span style="color: #F92672;">len</span>(<span style="color: #F92672;">self</span>.sequence))]
        <span style="color: #75715E;"># </span><span style="color: #75715E;">Insert elements of sequence into bucket.</span>
        <span style="color: #F92672;">for</span> a <span style="color: #F92672;">in</span> <span style="color: #F92672;">self</span>.sequence:
            buckets[a*<span style="color: #F92672;">len</span>(<span style="color: #F92672;">self</span>.sequence)/(<span style="color: #F92672;">max</span>(<span style="color: #F92672;">self</span>.sequence)+1)].append(a)
        <span style="color: #75715E;"># </span><span style="color: #75715E;">Use insertion sort to sort every sub-bucket in bucket.</span>
        <span style="color: #F92672;">for</span> b <span style="color: #F92672;">in</span> buckets:
            insertion_sort(b)
        <span style="color: #75715E;"># </span><span style="color: #75715E;">Extract elements of bucket</span>
        <span style="color: #FD971F;">serted_seq</span> = []
        <span style="color: #F92672;">for</span> c <span style="color: #F92672;">in</span> buckets:
            <span style="color: #FD971F;">serted_seq</span> += c
        <span style="color: #F92672;">return</span> serted_seq
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">Conclusion(总结)</h3>
<div class="outline-text-3" id="text-1-9">
<ul class="org-ul">
<li><b>Stability</b>

<p>
From <a href="http://en.wikipedia.org/wiki/Sorting_algorithm">http://en.wikipedia.org/wiki/Sorting_algorithm</a>
</p>


<div class="figure">
<p><img src="../Pic/Sort-stable-not-stable.png" alt="Sort-stable-not-stable.png" />
</p>
</div>
</li>

<li><b>Comparison of algorithms</b>

<p>
From <a href="http://en.wikipedia.org/wiki/Sorting_algorithm">http://en.wikipedia.org/wiki/Sorting_algorithm</a>
</p>

<p>
In this table, n is the number of records to be sorted. The columns "Average" and "Worst" give the time complexity in each case, under the assumption that the length of each key is constant, and that therefore all comparisons, swaps, and other needed operations can proceed in constant time. "Memory" denotes the amount of auxiliary storage needed beyond that used by the list itself, under the same assumption. The run times and the memory requirements listed below should be understood to be inside big O notation. Logarithms are of any base; the notation log<sup>2</sup> n means (log n)<sup>2</sup>.
</p>

<p>
These are all comparison sorts, and so cannot perform better than O(n log n) in the average or worst case.
</p>


<div class="figure">
<p><img src="../Pic/Sort-comparison-sorts.png" alt="Sort-comparison-sorts.png" />
</p>
</div>

<p>
The following table describes integer sorting algorithms and other
sorting algorithms that are not comparison sorts. As such, they are
not limited by a &Omega;(n log n) lower bound. Complexities below
assume n items to be sorted, with keys of size k, digit size d, and
r the range of numbers to be sorted. Many of them are based on the
assumption that the key size is large enough that all entries have
unique key values, and hence that n &lt;&lt; 2k, where &lt;&lt; means "much less
than."
</p>


<div class="figure">
<p><img src="../Pic/Sort-non-comparison-sort.png" alt="Sort-non-comparison-sort.png" />
</p>
</div>
</li>

<li><b>Some test of cost time</b>

<p>
From
<a href="http://www.cnblogs.com/huangxincheng/archive/2011/11/14/2249046.html">http://www.cnblogs.com/huangxincheng/archive/2011/11/14/2249046.html</a>
</p>


<div class="figure">
<p><img src="../Pic/Sort-cost-time-1.png" alt="Sort-cost-time-1.png" />
</p>
</div>


<div class="figure">
<p><img src="../Pic/Sort-cost-time-2.png" alt="Sort-cost-time-2.png" />
</p>
</div>


<div class="figure">
<p><img src="../Pic/Sort-cost-time-3.png" alt="Sort-cost-time-3.png" />
</p>
</div>


<div class="figure">
<p><img src="../Pic/Sort-cost-time-4.png" alt="Sort-cost-time-4.png" />
</p>
</div>
</li>

<li><b>A very good website about Algorithm</b>

<p>
Link: <a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">http://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a>
</p>
</li>
</ul>
</div>
</div>
</div>
